0xJQ
====
0xJQ is a jQuery plugin for getting high quality selectors of DOM nodes. It was
designed to provide most optimal, short pathes, which unambiguously points to a
single DOM element. The resulting selector is a byte array, after decoding  
CSS/jQuery compatible. It doesn't store only a path to a node, but also additional 
info about node's children or content. This data is used to find most similar node 
in the document after its structure has changed. Introduced algorithm is greedy 
heuristic. 

Getting started
---------------
Let's start with some sample DOM:

        <ul class="list">
            <li class="element" title="Cras non commodo ante">
                <p>
                    Nam <b>imperdiet</b> arcu vitae fringilla porta. Cras non commodo 
                    ante, sed egestas <i>est</i>. Suspendisse vel laoreet turpis. 
                </p>
            </li>
            <li class="element" style="border-bottom: 2px solid blue">
                In quis pellentesque magna, quis aliquam orci. In convallis, magna 
                nec <a>blandit</a> dapibus, nibh metus ultrices nibh, vel varius 
                augue augue id nulla. 
            </li>
            <li class="element" id="second">
                <span>Donec sed lobortis nisl. Etiam pulvinar eu augue ac ullamcorper.</span>
            </li>
        </ul>

Imagine you need to get reference (selector) to second li element. It's quite easy 
with 0xJQ:

var ref = $('li:eq(1)').xJQ();

Now, whenever you do `$.xJQ(ref)` you will get jQuery object same as `$(original)` 
one. We could for example change its background:

$.xJQ(ref).css('background-color', 'red');

When you preview ref variable you will see that it's an array of bytes, in our 
case 19 bytes long. When the DOM is fixed, it does fairly the same job as jQuery 
string selector. Its real power reveals when you deal with dynamic DOM ( async 
upadated or generated by server side scripts ) and want to keep unbroken reference 
even though elements on page change its order and some of them are wrapped in 
additional containers. 0xJQ selectors takes into account not only position of 
element and its type but also its content which makes them more flexible. Let's 
keep our `ref` variable unchanged, you could e.g. save it to cookie. Now change your 
DOM:

        <ul class="list">
            <li class="first element" title="Cras non commodo ante">
                <p>
                    THIS CONTENT WAS DELETED
                </p>
            </li>
            <li class="element" style="border-bottom: 2px solid blue">
                <span>Donec sed lobortis nisl. Etiam pulvinar eu augue ac ullamcorper.</span>
            </li>
            <li class="element" id="second">
                <h1>In quis pellentesque magna</h1>
                <p>
                    In quis pellentesque magna, quis aliquam orci. In convallis, 
                    nec <a>blandit</a> dapibus, nibh metus <a>NEW</a> ultrices nibh, 
                    vel varius augue id nulla. 
                </p>
            </li>
        </ul>

When you reapply your `ref` selector on current structure you may feel some magic 
of 0xJQ. It doesn't refer to `li:eq(1)` anymore. Now you get internal `<p>` of 
third `<li>` tag. Why? Because 0xJQ decided that it's more similar to the orginal 
`li:eq(1)`.

Quality of selectors
--------------------
How 0xJQ judges that one selector is better than the other? It takes into account few
factors: the uniqueness of each part of the selector, length after encoding and 
some arbitrary assessments established after analysing common DOM's life-cycle.
Best selectors are short ids and classes which are unique in whole document.
However in most cases short selectors doesn't mean best. Take a look at sample 
DOM structure:

    <section>
        <div id="someverylongid" class="ok child"></div>
        <p class="child"></p>
        <p class="child"></p>
        <p class="child"></p>
        <p class="child"></p>
    </section>
    <span class="footer">
        <span class="child"></span>
    </span> 

You may ask yourself: What is the shortest selector for the div element? 
It's probably the 'div'. There is no other div element in the DOM, moreover this 
selector is known html keyword and could be easliy encoded by dictionary key. 
But is it a really good selector? When you e.g. save it to cookie you probably 
want to keep reference to the element regardless of future DOM changes. 
It's rather common to add new div elements to the HTML's body ( when DOM is 
generated programmatically it can vary even between page loads ), so 'div' isn't 
the best selector when DOM is prone to changes. In this case best would be 
'#someverylongid', which guarantees better uniqueness, even though it takes at 
least 14 bytes. What we can say about `.child`? This class is used for 6 elements
in the document what makes proposed selector rather useless. It's probably one of 
those general classes which are pasted all over around, for sure there will be 
more `.child`ren in `section`. Most optimal are '.ok' or 'section .ok', which 
are short and unique.

Selectors used in 0xJQ listed in order from specific (preferred) to general ones:
ID Selector #id
Class Selector .class
Attribute Starts With Selector [name^="value"]
Has Attribute Selector [name]
Element Selector element
Child Selector parent > child
Descendant Selector ancestor descendant
:eq() Selector

Similarity of DOM nodes
-----------------------
When $.xJQ function can't find element by selector or found element has diffrent
content, the algorithm will look for most similar nodes ( whose distance doesn't 
exceed defined treshold ) `generalLevels` levels up to the root element, and than 
`approxLevels` levels down. To check similarity, the alogorithm calculates distances 
between frequency vectors ( containing frequency of child nodes or text chunks ). 

Optional params
---------------
### $().xJQ encoder
`compressRatio` ( 0.0 - 1.0 ) - ratio between most compact ( 1.0 ), and best 
quality ( 0.0 ) result
`contentShinglesNum` - length of frequency vector
  
### $.xJQ decoder
`similarityThreshold` - maximum threshold for distance of frequency vectors, to 
treat them as identical

### shared
`rootSelector` - jQuery element or string selector which will be the root node
of all calculations, the result could be interpreted 

Internal format
---------------
0xJQ selectors consist of 3 parts. The first part is encoded css selector without 
class names and attribute values which come right after, organized in array. At 
the end there are encoded frequencies of child tags or text chunks, which identify
the selected element by its content.

Bugs and testing
----------------
Used algorithm doesn't guarantee optimal results in all cases. It was automaticaly 
tested, by getting references to some random elements on popular websites. The
produced selectors were correct ( after decoding with $.xJQ, they were pointing
to orginal elements ), however some of them were pretty long ~ 100 bytes. Future
version of the library will be optimized to work better with those edge cases.

Optimizing DOM
--------------
Best way to help 0xJQ with providing short, high quality selectors is to add unique,
and short attributes ( `id` or `class` are best ) to all selected elements. You could
also play with options to alter result in the way that will fit your needs. 
